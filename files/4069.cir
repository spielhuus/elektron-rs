Label("INPUT"){rotate(180)}
  -> Symbol("R1", "Device:R", value="100k", Spice_Netlist_Enabled="Y"){rotate(90)}
  -> Symbol("C1", "Device:C", value="47n", Spice_Netlist_Enabled="Y"){rotate(90)}
  -> Dot(){id(u1_dot_in)}
  -> Symbol("U1", "4xxx:4069", value="4069", unit=1, Spice_Primitive="X", Spice_Model="4069UB")
  -> Dot(){id(u1_dot_out)}
  -> Symbol("C2", "Device:C", value="1u", Spice_Netlist_Enabled="Y"){rotate(90)}
  -> Dot(){id(out_dot)}  
  ->{length(2.54)} Label("OUTPUT")

(u1_dot_out) ->{up, length(12.7)}
  -> Symbol("R2", "Device:R", value="100k", Spice_Netlist_Enabled="Y"){rotate(270), tox(u1_dot_in)}
  ->{down, toy(u1_dot_in)}

(out_dot)
  -> Symbol("R3", "Device:R", value="1Meg", Spice_Netlist_Enabled="Y"){anchor(1)}
  -> Symbol("GND", "power:GND", Spice_Netlist_Enabled="Y")


.control
let vccc = 1.2            ; create a vector vccc and assign value 1.2
repeat 5                  ; loop start
  alter Vcc $&vccc        ; alter the voltage Vcc using vector vccc
  dc vin 0 2 0.01         ; run the dc simulation
  let vccc = vccc + 0.2   ; calculate new voltage value for Vcc by updating vector vccc
end                       ; loop end, jump back to loop start
set xbrushwidth=2         ; assign value 2 to the predefined variable
plot dc1.v(out) dc2.v(out) dc3.v(out) dc4.v(out) dc5.v(out)
set nounits               ; do not plot units on the x and y axes.
plot deriv(dc1.v(out)) deriv(dc2.v(out)) deriv(dc3.v(out)) deriv(dc4.v(out)) deriv(dc5.v(out)) ylabel 'Inverter gain V / V' xlabel 'vsweep V'
unset nounits             ; undo the previous set command
plot dc1.I(vcc) dc2.I(vcc) dc3.I(vcc) dc4.I(vcc) dc5.I(vcc) ylabel 'Inverter current consumption'
.endc
